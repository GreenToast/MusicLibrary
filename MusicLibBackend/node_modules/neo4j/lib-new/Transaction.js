// Generated by CoffeeScript 1.8.0
(function() {
  var FAR_FUTURE_MS, Transaction, errors, utils;

  errors = require('./errors');

  utils = require('./utils');

  FAR_FUTURE_MS = Date.now() + 1000 * 60 * 60 * 24 * 365;

  module.exports = Transaction = (function() {
    function Transaction(_db) {
      this._db = _db;
      this._id = null;
      this._expires = null;
      this._pending = false;
      this._committed = false;
      this._rolledback = false;
    }

    Object.defineProperty(Transaction.prototype, 'expiresAt', {
      enumerable: true,
      get: function() {
        if (this._expires) {
          return new Date(this._expires);
        } else {
          return new Date(FAR_FUTURE_MS);
        }
      }
    });

    Object.defineProperty(Transaction.prototype, 'expiresIn', {
      enumerable: true,
      get: function() {
        if (this._expires) {
          return this.expiresAt - (new Date);
        } else {
          return Infinity;
        }
      }
    });

    Object.defineProperty(Transaction.prototype, 'state', {
      get: function() {
        switch (false) {
          case !this._pending:
            return 'pending';
          case !this._committed:
            return 'committed';
          case !this._rolledback:
            return 'rolled back';
          case !(this.expiresIn <= 0):
            return 'expired';
          default:
            return 'open';
        }
      }
    });

    Transaction.prototype.cypher = function(opts, cb) {
      var errMsg;
      if (opts == null) {
        opts = {};
      }
      errMsg = (function() {
        switch (this.state) {
          case 'pending':
            return 'A request within this transaction is currently in progress. Concurrent requests within a transaction are not allowed.';
          case 'expired':
            return 'This transaction has expired. You can get the expiration time of a transaction through its `expiresAt` (Date) and `expiresIn` (ms) properties. To prevent a transaction from expiring, execute any action or call `renew` before the transaction expires.';
          case 'committed':
            return 'This transaction has been committed. Transactions cannot be reused; begin a new one instead.';
          case 'rolled back':
            return 'This transaction has been rolled back. Transactions get automatically rolled back on any DatabaseErrors, as well as any errors during a commit. That includes auto-commit queries (`{commit: true}`). Transactions cannot be reused; begin a new one instead.';
        }
      }).call(this);
      if (errMsg) {
        throw new errors.ClientError(errMsg);
      }
      this._pending = true;
      return this._db.cypher(opts, (function(_this) {
        return function(err, results) {
          _this._pending = false;
          if (_this._id) {
            return cb(err, results);
          }
          if (opts.commit && !err) {
            _this._committed = true;
          } else {
            _this._rolledback = true;
          }
          return cb(err, results);
        };
      })(this), this);
    };

    Transaction.prototype.commit = function(cb) {
      return this.cypher({
        commit: true
      }, cb);
    };

    Transaction.prototype.rollback = function(cb) {
      return this.cypher({
        rollback: true
      }, cb);
    };

    Transaction.prototype.renew = function(cb) {
      return this.cypher({}, cb);
    };

    Transaction.prototype._updateFromResponse = function(resp) {
      var body, headers, statusCode, transaction, transactionURL;
      if (!resp) {
        throw new Error('Unexpected: no transactional response!');
      }
      body = resp.body, headers = resp.headers, statusCode = resp.statusCode;
      transaction = body.transaction;
      if (!transaction) {
        this._id = this._expires = null;
        return;
      }
      this._expires = new Date(transaction.expires);
      if (this._id) {
        return;
      }
      if (statusCode !== 201) {
        throw new Error('Unexpected: transaction returned by Neo4j, but it was never 201 Created, so we have no ID!');
      }
      if (!(transactionURL = headers['location'])) {
        throw new Error('Unexpected: transaction response is 201 Created, but with no Location header!');
      }
      return this._id = utils.parseId(transactionURL);
    };

    return Transaction;

  })();

}).call(this);

//# sourceMappingURL=Transaction.js.map
